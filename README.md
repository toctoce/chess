# ♟️ Java Chess Game

- 우아한테크코스 프리코스 4주차 오픈 미션 프로젝트
- 스프링 부트와 웹소켓을 활용한 실시간 1:1 멀티플레이 체스 게임입니다.

## 🔗 배포 링크

👉 Play Chess: http://www.woowa-chess.store:8080

- 멀티플레이만 지원하니, 혼자서 하고 싶다면 기본 웹 브라우저와 시크릿모드를 동시에 사용하시면 됩니다.

## 🎯 프로젝트 목표

1. 객체지향적 설계
    - 모든 로직을 Game 클래스에 몰아넣지 않고, Piece, Board, Game 등 객체에게 적절한 책임과 역할을 부여하여 협력하도록 설계했습니다.
2. 디자인 패턴 적용
    - 복잡한 체스 규칙과 게임 로직을 효율적으로 관리하기 위해 적재적소에 디자인 패턴을 적용했습니다.
3. 서비스 배포
    - 로컬 환경을 넘어 실제 사용자가 접속할 수 있는 클라우드 환경에 배포하고, 도메인을 연결했습니다.

## 🛠️ 기술 스택

- 언어: Java 21
- 프레임워크: Spring Boot 3.5.7
- 빌드 도구: Gradle
- 통신: WebSocket (STOMP), HTTP REST API
- 테스트: JUnit 5, AssertJ, Mockito
- 인프라: AWS EC2 (Amazon Linux 2023), 가비아 (DNS)

## 🏗️ 디자인 패턴 및 아키텍처

코드의 복잡성을 줄이고 확장성을 높이기 위해 다음과 같은 디자인 패턴을 적용했습니다.

### 1. 전략 패턴

- 적용: `Piece`마다 제각각인 이동 규칙(`KingMovement`, `PawnMovement` 등)을 별도의 전략 클래스로 분리했습니다.
- 효과: 복잡한 `if-else` 분기를 제거하고, 새로운 기물이 추가되더라도 기존 코드를 수정할 필요 없이 새로운 전략만 추가하면 되는 개방 폐쇄 원칙을 준수했습니다.

### 2. 추상 팩토리 패턴

- 적용: `PieceFactory` 인터페이스를 정의하고, 이를 구현하는 `WhitePieceFactory`와 `BlackPieceFactory`를 만들었습니다.
- 효과: 색에 따라 일관성 있는 기물 세트를 생성할 수 있으며, 객체 생성 로직과 비즈니스 로직을 명확히 분리했습니다.

### 3. 메멘토 패턴

- 적용: 매 턴마다 보드의 상태를 불변 객체인 `BoardSnapshot`으로 저장하고, 이를 `GameHistory`에서 스택으로 관리합니다.
- 효과: 게임의 내부 상태를 캡슐화하면서도, 스택에서 스냅샷을 꺼내는 방식으로 손쉽게 무르기 기능을 구현했습니다.

## 🧩 구현

### 1. 체스 규칙의 완벽한 구현

- 체스의 기본적인 이동 규칙, 복잡한 특수 규칙을 구현했습니다.
- 특수 규칙
    - 캐슬링: 킹과 룩의 위치를 동시에 변경하는 전략적인 이동을 지원합니다.
        - 조건: 킹과 룩이 한 번도 움직이지 않아야 하며, 사이의 경로에 장애물이 없어야 합니다. 또한 킹이 이동하는 경로가 공격받지 않는 안전한 상태여야 합니다.
    - 폰의 고유 규칙:
        - 초기 이동: 폰은 첫 이동 시에 한해 두 칸 전진이 가능합니다.
        - 앙파상: 상대 폰이 두 칸 전진하여 내 폰 바로 옆에 도착했을 때, 마치 한 칸만 움직인 것처럼 간주하여 대각선으로 잡을 수 있습니다.
        - 승진: 폰이 상대 진영의 마지막 랭크에 도달하면 퀸으로 승격됩니다.

- 승패 및 무승부 판정
    - 승리/패배:
        - 체크메이트: 킹이 공격받고 있으며, 어떠한 수로도 위협을 피할 수 없는 경우.
    - 무승부 (Draw):
        - 스테일메이트: 현재 턴의 플레이어가 체크 상태가 아니지만, 둘 수 있는 합법적인 수가 없는 경우.
        - 기물 부족: 남은 기물로 체크메이트를 시키는 것이 불가능한 경우.
            - 킹 vs 킹
            - 킹 vs 킹 + 부기물
            - 킹 vs 킹 + 2 나이트
            - 킹 + 부기물 vs 킹 + 부기물
        - 50수 규칙: 50수 동안 폰의 이동이 없고, 기물을 잡는 행위가 없을 경우.
        - 3회 반복: 동일한 보드 상태(기물 배치, 턴, 캐슬링 권한 등)가 3번 반복될 경우.

### 2. 실시간 멀티플레이

- Spring WebSocket과 STOMP 프로토콜을 도입하여 양방향 통신을 구현했습니다. Pub/Sub 모델을 통해 플레이어가 수를 두는 즉시 상대방의 화면에 반영되는 실시간 통신을 제공합니다.

### 3. 무르기

- 메멘토 패턴을 활용하여 매 턴의 보드 상태를 스택에 저장합니다. 이를 통해 사용자는 언제든 이전 상태로 게임을 되돌릴 수 있습니다.

### 4. 예외 처리

- 게임 로직에서 발생하는 다양한 예외(`IllegalMoveException`, `RuleViolationException` 등)를 `@RestControllerAdvice`를 통해 일관된 방식으로 처리합니다.
- 서버 내부의 에러 메시지를 규격화된 JSON 포맷으로 변환하여 클라이언트에게 전달하며, 프론트엔드는 이를 사용자에게 명확한 피드백으로 제공합니다.

## 프로젝트 구조

```text
chess
├── config          # 의존관계 주입
├── controller      # 요청 처리 및 예외 핸들링
├── service         # 비즈니스 로직
├── repository      # 데이터 저장소
├── domain
│   ├── board       # Board, Position
│   ├── game        # Game, Player, History
│   ├── piece       # 기물 추상화 및 구현체
│   ├── strategy    # 이동 전략
│   ├── status      # 게임 상태 판별
│   └── factory     # 기물 생성 팩토리
└── dto             # 데이터 전송 객체
```